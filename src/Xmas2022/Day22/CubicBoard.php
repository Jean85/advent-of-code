<?php

declare(strict_types=1);

namespace Jean85\AdventOfCode\Xmas2022\Day22;

class CubicBoard extends Board
{
    private readonly int $cubeSideLength;

    public function __construct(string $input)
    {
        parent::__construct($input);

        $total = 0;
        foreach ($this->map as $row) {
            $total += count($row);
        }

        $this->cubeSideLength = (int) sqrt($total / 6);
    }

    public function executeOneInstruction(): void
    {
        file_put_contents(__DIR__ . '/output.txt', $this->printMap());
        parent::executeOneInstruction(); // TODO: Change the autogenerated stub
    }

    protected function wrapAroundEdge(int $newX, int $newY): array
    {
        $edgeDirection = $this->currentDirection->turn(Turn::Right);

        $neededTurns = 1;
        $additionalTurns = 1;
        $stepSinceLastTurn = (int) match ($edgeDirection) {
            Direction::Right => $newX % $this->cubeSideLength,
            Direction::Down => $newY % $this->cubeSideLength,
            Direction::Left => $this->cubeSideLength - ($newX % $this->cubeSideLength),
            Direction::Up => $this->cubeSideLength - ($newY % $this->cubeSideLength),
        };
        $neededStepsAfterLastTurn = 0;
        $neededStepsIdentified = false;

        // walk around the edges, counting the turns
        while ($neededTurns > 0) {
            $newX += $edgeDirection->toX();
            $newY += $edgeDirection->toY();

            if (isset($this->map[$newY][$newX])) {
                $newX -= $edgeDirection->toX();
                $newY -= $edgeDirection->toY();
                $edgeDirection = $edgeDirection->turn(Turn::Left);
                $additionalTurns = -1;
                $neededTurns += $additionalTurns;
                $neededStepsIdentified = true;
                $stepSinceLastTurn = 1;
            } elseif ($this->positionToTheRightIsNotSet($edgeDirection, $newX, $newY)) {
                $edgeDirection = $edgeDirection->turn(Turn::Right);
                $neededStepsIdentified = true;
                $neededTurns += $additionalTurns;
                $stepSinceLastTurn = 0;
            } elseif (++$stepSinceLastTurn > $this->cubeSideLength) {
                $neededStepsIdentified = true;
                $neededTurns += $additionalTurns;
                $stepSinceLastTurn = 1;
            } elseif (! $neededStepsIdentified) {
                ++$neededStepsAfterLastTurn;
            }
        }

        // advance along the last edge
        while ($neededStepsAfterLastTurn--) {
            $newX += $edgeDirection->toX();
            $newY += $edgeDirection->toY();
        }

        // adjust position & direction by stepping into the cube, over the edge
        $this->currentDirection = $edgeDirection->turn(Turn::Right);
        $newX += $this->currentDirection->toX();
        $newY += $this->currentDirection->toY();

        return [$newX, $newY];
    }

    private function positionToTheRightIsNotSet(Direction $direction, int $x, int $y): bool
    {
        $direction = $direction->turn(Turn::Right);
        $newX = $x + $direction->toX();
        $newY = $y + $direction->toY();

        return ! isset($this->map[$newY][$newX]);
    }
}
